# 场景相关功能介绍

## 场景：

游戏中的协议都是继承于CProtolBase，角色很多的行为也是通过协议的方式来实现的，例如角色瞬移协议（s_map_goto_m_81.py）、角色飞行（s_map_fly_225.py）、角色移动轨迹的同步（s_map_track_86.py）、通知消息协议（s_notify_255.py）等等，下面我就介绍一下关于场景切换协议（s_map_scene_80.py）、处理角色瞬移的网络协议（s_map_goto_m_81.py）、游戏场景中播放特效（s_map_effect_88.py）。同步队伍信息（s_map_team_89.py）。

### 场景切换：

​	场景的基类时SceneBase，Scene和EditorScene都继承这个类，Scene类负责普通游戏场景的管理，而EditorScene类则负责编辑器场景的管理，并提供了更多编辑器相关的功能和定制化的逻辑。

#### 详细步骤：

**协议文件：**s_map_scene_80.py

**协议号：**80

**FMT：**定义进入场景时的各种数据，如场景ID，坐标、昼夜、时装、光环、坐骑、飞行状态。

1.  `pre_handler` : 在处理协议之前做一下预处理，在协议处理前记录需要切换场景的次数，并在切换场景的过程中过滤掉某些协议，以优化场景切换的性能。它可能是为了处理连续跨场景寻路的情况，避免不必要的协议处理。
2.  `handler` : 判断是否是调试模式，如果是调试模式，在开启调试模式时，输出场景切换的相关调试信息。
3.  `global_data.prop_inited` 字段表示主角是否初始化，没有初始化完成就不处理该协议、
4.  判断trigger，有些玩法可能会屏蔽切场景时间，就会注册`TRG_ON_LOAD_SCENE`的回调，根据trigger.run该方法的返回值判断是否需要继续处理切场景逻辑
5.  global_data.enable_load_plist_opt该字段表示是否开启plist load优化，set_global_enable_load_plist()、set_is_in_war_for_plist这俩方法暂时不生效，怀疑是测试阶段的代码。
6.  global_data.s_map_scene_info["scene"] = data.scene：将 data.scene 的值赋给 global_data.s_map_scene_info 字典中的 "scene" 键，用于更新当前场景的信息。然后使用日志记录器输出日志，然后再清空下场景大的遮罩物品。
7.  猜测是之前出现相关的bug，这里会通过global_warinfo.is_war()判断是不是在战斗中，在战斗中尝试切换城市场景，然后直接返回，不执行后续的场景切换逻辑。
8.  根据接受到的数据来确定当前场景是白天还是黑夜。然后将值赋给day_or_nigh
9.  global_data.not_remove_aoi_player清楚掉一些玩法相关的全局数据，切场景时应该去掉这些配置
10.  svr_grid_convert_to_mobile_pixel()服务器格子坐标转换成手游像素坐标接收转换后的数据，然后删除调用hero.destroy()删除主角
11.  判断是不是通风幻阵，是的话就不进行操作。不是话就正常切换场景，那么切入场景 先不强制加载背景图，然后调用change_scene()该函数进行场景的切换，同时也更新白天黑夜地状态。
12.  通过SceneRegionMgr().can_use_trigger = True恢复触发器，MapUI更新数据(主界面左上角的地图信息)，然后发送主角位置更新事件，通知其他模块主角位置的变化。
13.  然后判断当前场景是否可以显示坐骑，如果不能显示，则将坐骑参数设置为 0，然后判断当前场景是否为通风幻阵，并且是否在进行视角移动。
     如果不是通风幻阵或者不在进行视角移动，则调用 creat_hero_in_scene 函数在当前场景中创建主角。如果是通风幻阵并且正在进行视角移动，则通过 SceneEvent 的 `add_huanzhen_hero_data` 事件通知其他模块控制通风幻阵中的英雄。
14.  如果没有启用登录速度优化选项，则刷新当前场景的黑暗度(`refresh_scene_darkness()`)。
15.  `load_randmap`加载随机地图数据
16.  加载场景地图特效：`add_scene_stuff`
17.  `load_puzzle_info`加载组合迷宫，如修罗密藏
18.   `TerrainManager().load_scene_terrains`：加载场景的地形块，根据场景ID，将地形块数据加载到场景中。
19.  `SceneMapUI.clear_no_smallmap_scenes()`：清空屏蔽的小地图场景、副本小地图场景和小地图文字场景，确保切换到新场景后，小地图相关的设置得到重置。
20.  清空屏蔽的副本小地图（`clear_no_smallmap_dungeon_scenes()`）、小地图文字（`clear_no_smallmap_text_scenes()`）、前一次剧情动画（      `npc_film_mgr.stop_film()`）
21.  根据飞行相关的数据，处理飞行逻辑，可能是开始飞行或处理飞行数据包。如果角色没有在飞行状态，则清除云朵生成器（`clear_cloud_generator（）`）。
22.  在游戏中清理房屋和解放建筑周围的物品或障碍物，以确保环境的整洁和建筑的正常运作。`clear_house_item_around()`、`clear_jiefang_item_around()`
23.  `check_is_new_scene()`每次重载入场景时检查是进入新场景还是从战斗中出来。进新场景时要清掉direct_npc_name(需要指引的npc名字)，而从战斗中出来不用
24.  在切换场景时刷新玩家的可见性设置。
25.  服务器对场景属性状态的控制：通过对地图数据的解析和处理，游戏可以动态地控制不同场景的显示和交互方式，提供更丰富和多样化的游戏体验。
26.  检查主角是否有跟随npc，用于骆陀：场景切换后进行的一些检查和处理逻辑，包括主角状态检查、跟随 NPC 的创建以及阻挡块的调试绘制。
27.  进入庭院场景取消屏蔽玩家状态：根据`tingyuan_architecture.TINGYUAN_SCENE`字段来判断是否处于庭院场景
28.  检测是否弹出性能提示框：show_performance_tips_dlg()，判断的依据是：`检查当前的机器显存是否小于1G;显存大于1G，小于2G且开两个以上客户端`。

#### 重要逻辑记录：

##### **change_scene：**场景切换

```Python
    def change_scene(
        self,
        scene_id,
        war_scene=False,
        look_center_pos=None,
        do_not_reset_film=False,
        night_id=None,
        need_clear=True,
    ):
        super(EditorScene, self).change_scene(
            scene_id,
            war_scene,
            look_center_pos,
            do_not_reset_film,
            night_id,
            need_clear,
        )
        if self._editor_soul:
            self._editor_soul.on_scene_change(scene_id)

```

方法接受多个参数，包括场景 ID、是否为战斗场景、视角中心位置、是否重置镜头、夜晚场景 ID 以及是否需要清除场景。

详细步骤如下：

1. 导入必要的模块和类，如 Scene3DMgr、SceneSwitchEvent、SceneEvent 等。

2. 记录上一个场景的 ID（self._last_scene_id）和当前要切换到的场景 ID（self._scene_id）。

3. 判断是否为非战斗同场景切换（self.same_scene_clearing），根据一些条件进行判断，如是否启用延迟销毁、上一个场景和当前场景是否相同、是否处于战斗状态等。

4. 如果是同场景切换且需要清除场景，记录开始切换的帧数（self.ss_clearing_frame）。

5. 如果启用了场景切换管理器，触发场景捕获开始事件（SceneSwitchEvent().on_scene_capture_start.emit()）。

6. 触发场景销毁事件（SceneEvent().on_scene_destroy.emit()）。

7. 重置英雄同步步骤标记（global_data.hero_sync_step_tag）。

8. 清理待加载场景特效数据（self.clear_scene_stuff_data()）。

9. 销毁屏幕上的特效（self.destroy_screen_stuffs()）。

10. 重置图层管理器的当前子索引和运行时参数（self.layer_mgr.reset_cur_sub_index()、self.layer_mgr.reset_runtime_params()）。

11. 如果需要清除场景（need_clear），调用 self.clear(do_not_reset_film) 清空当前场景；否则，设置场景缩放比例（self.scene_scale）。

12. 重置同场景切换标记（self.same_scene_clearing）。

13. 设置夜晚场景的 ID（self.night_id）。

14. 切换 Neox 物理场景：
    1. 销毁之前的场景管理器（self._scene_3d_mgr.destroy()）。
    2. 创建新的场景管理器（self._scene_3d_mgr = Scene3DMgr(scene_id)）。
    3. 根据是否启用异步加载场景，调用相应的方法切换 Neox 场景（self._scene_3d_mgr.change_neox_scene() 或 player.change_neox_scene()）。
    4. 更新 Neox 相机（self._neox_camera）。
    5. 如果不是异步加载，设置场景并绑定事件（self._scene_3d_mgr.set_scene()、self._scene_3d_mgr.bind_event()）。
15. 设置当前场景为战斗场景标识（self.war_scene_env）。
16. 如果启用了场景切换管理器，触发场景切换开始事件和场景背景改变事件（SceneSwitchEvent().on_scene_switch_start.emit()、SceneSwitchEvent().on_scene_background_changed.emit()）。

17. 加载场景（self.load_scene(scene_id, look_center_pos)）。

18. 如果不需要重置镜头且正在播放 NPC 电影，停止播放电影（NpcFilmManager().stop_film()）。

19. 如果不需要重置镜头，更新电影对象的位置（obj.set_pixel_pos()）。

20. 如果需要清除场景，创建用于显示影子的特效（self.create_shadow_displayer()）。

21. 创建虚拟特效（self.create_dummy_stuffs()）并更新屏幕特效位置（self.update_screen_stuff_pos()）。

22. 触发相机缩放比例改变事件（self.on_camera_scale_changed()）。

23. 应用场景亮度（self.apply_scene_lightness()）。

24. 创建场景关卡（self._scene_3d_mgr.create_scene_level()）。

##### MapUI().update_scene：小地图更新

```python
   def update_scene(self, scene):
        if MapUIData().custom_scene_name:
            return
        if global_scene.scene_id in global_scene.scene_name_cache:
            scene = global_scene.scene_name_cache[global_scene.scene_id]
        self._scene = scene
        self.txt_scene_name.text = "%s [%s,%s]" % (
            self._scene,
            self.pos[0],
            self.pos[1],
        )
        # 如果微地图打开中，且不处于战斗状态，就更新
        if self._is_show_micro_map and (not global_warinfo.is_war()):
            from common_system.main_ui.map_utils import check_enable_show
            from common_system.main_ui.micro_map_ui import MicroMapUI
            from wanfa.duanwu_2022.dragon_boat.dragon_boat_micro_map_ui import (
                DragonBoatMicroMapUI,
            )
            from wanfa.duanwu_2022.dragon_boat.dragon_boat_util import (
                check_in_dragon_boat_game,
            )

            if (
                check_in_dragon_boat_game(check_game_state=True)
                and DragonBoatMicroMapUI.get_instance()
            ):
                DragonBoatMicroMapUI.get_instance().update_micro_map()
                return
            # 如果没有可显示的微型地图就收缩回去
            if check_enable_show():
                MicroMapUI().update_micro_map()
            else:
                self.btn_micro_map_onClick(None)

        elif global_warinfo.is_war():
            pass
```

1. 首先，检查 MapUIData().custom_scene_name 是否有值。如果有自定义场景名称，直接返回，不进行后续的更新操作。

2. 如果没有自定义场景名称，则尝试从 global_scene.scene_name_cache 中获取当前场景的名称。使用当前场景的 ID（global_scene.scene_id）作为键来查找对应的场景名称，并将其赋值给 self._scene。

3. 更新场景名称显示。将场景名称、当前位置的 x 坐标和 y 坐标组合成一个字符串，并赋值给 self.txt_scene_name.text，用于在界面上显示场景名称和坐标信息。

4. 接下来，判断是否满足更新微型地图的条件：

5. 如果微型地图正在显示（self._is_show_micro_map 为 True）且当前不处于战斗状态（not global_warinfo.is_war()），则进行微型地图的更新。
   导入必要的模块和类，如 check_enable_show、MicroMapUI、DragonBoatMicroMapUI、check_in_dragon_boat_game 等。

6. 检查是否处于端午节龙舟游戏中（check_in_dragon_boat_game(check_game_state=True)）且龙舟微型地图实例存在（DragonBoatMicroMapUI.get_instance()）。如果满足条件，调用 DragonBoatMicroMapUI.get_instance().update_micro_map() 更新龙舟微型地图，然后直接返回。

7. 如果不在龙舟游戏中，则调用 check_enable_show() 检查是否有可显示的微型地图。
   - 如果有可显示的微型地图，调用 MicroMapUI().update_micro_map() 更新普通的微型地图。
   - 如果没有可显示的微型地图，调用 self.btn_micro_map_onClick(None) 收缩微型地图。
8. 如果当前处于战斗状态（global_warinfo.is_war()），则不进行任何操作。

##### creat_hero_in_scene：在场景里创建英雄

```python
def creat_hero_in_scene(data, sobj):
    # 通过中间服登录时，这条进场协议可能在hero init之前发送一次，所以这里先判断hero是否init过
    from gcommon.dutils import resource_utils
    from gcommon.dutils.hero_utils import get_name_color_by_rei
    from gcommon.event.scene_event import SceneEvent
    from gcommon.walker_interface import DEFAULT_RUN_SPEED
    from walker import HeroWalker

    if global_data.hero_prop.get("id") is None:
        logger.warning("global_data.hero_prop not init")
        return

    shape = global_data.hero_prop.layout
    photo = resource_utils.get_photo_by_shape(shape)
    if shape != data.ori_shape:
        cmp_photo = resource_utils.get_photo_by_shape(data.ori_shape)
        # 保护一下一些奇怪的造型,可能会变成小黑人,做好坐骑的话应该就不用管这里了
        if (
            cmp_photo == photo or photo > 10000
        ) and not resource_utils.is_child_layout(shape):
            shape = data.ori_shape

    data.shape = data.get("org_shape") or shape  # 初始值用org_shape
    global_data.hero_prop.layout = shape
    global_data.hero_prop.gs_level = data.get("gs_level", 0)
    global_data.hero_prop.ori_shape = data.get("ori_shape", 0)
    hero = HeroWalker(global_data.hero_prop.id, data)
    sobj.set_hero(hero)
    # 确保有徽章就会设置
    name = global_data.hero_prop.name
    badge = global_data.hero_prop.get("badge", None)
    name_color = get_name_color_by_rei(
        global_data.hero_prop.rei, global_data.hero_prop.flyup
    )
    hero.set_name(name, badge, name_color)
    title = global_data.hero_prop.get("title", None)
    if title:
        hero.set_title(title)
        # 更新自己称谓信息，用于更新组队显示
        from common_system.friend_sys.recent_teammate import (
            RecentTeammateManager,
        )

        self_data = RecentTeammateManager().get_self_info()
        if self_data is not None:
            self_data["title"] = title
    if global_data.hero_show_phantom:
        hero.need_show_phantom = True
    if global_data.hero_run_speed:
        hero.ani.run_speed = global_data.hero_run_speed

    hero.photo = resource_utils.get_photo_by_shape(data.ori_shape)
    global_data.hero_prop.fashiondress = data.fashiondress
    global_data.hero_prop.weapon_dress = data.weapon_dress
    if hasattr(data, "cfashion_data"):
        global_data.hero_prop.cfashion_data = data.cfashion_data

    if hasattr(data, "store_index") and hasattr(data, "store_zdeep"):
        hero.set_store_trinket_pos(data.store_index, data.store_zdeep)

    # 根据端游表现，多人座驾也显示装饰品
    # is_show_trinket = not hero._is_on_mult_zuojia()
    is_show_trinket = True
    is_show_halo = not hero._is_on_mult_zuojia()

    if is_show_trinket and not global_data.is_play_shilian:
        if hasattr(data, "trinket"):
            hero.dress_trinket.add_trinket(data.trinket)
    if is_show_halo and not global_data.is_play_shilian:
        if hasattr(data, "halo"):
            hero.dress_trinket.add_binfen_effect(data.halo)
    if hasattr(data, "footprint"):
        hero.dress_trinket.add_footprint(data.footprint)

    # 主角装饰品强制加载plist
    hero.dress_trinket.set_force_enable_load_plist(True)

    # hero.type = SCENE_PLAYER_TYPE
    # print 'process s map scene change %d ' % data.scene
    hero.type = "英雄"
    # 如果在普通场景（非war_scene）主角隐藏，重新创建也需要隐藏
    hero_id = hero.obj_id
    if hero_id in global_scene.hidden_objects:
        global_scene.hide_object(hero_id, True)  # 隐藏角色

    SceneEvent().add_obj_to_scene.emit(hero)
```

1. 首先，导入必要的模块和类，如 resource_utils、get_name_color_by_rei、SceneEvent、DEFAULT_RUN_SPEED 和 HeroWalker。

2. 检查全局数据 global_data.hero_prop 中的 id 是否为 None。如果是，说明英雄属性尚未初始化，输出警告日志并直接返回。

3. 获取英雄的造型 shape，并通过 resource_utils.get_photo_by_shape(shape) 获取对应的照片 photo。

4. 如果当前造型 shape 与数据中的原始造型 data.ori_shape 不同，则获取原始造型对应的照片 cmp_photo，并进行一些保护性的判断和处理，以避免出现奇怪的造型变化。

5. 设置英雄的各种属性，如造型 data.shape、等级 data.gs_level、原始造型 data.ori_shape 等。

6. 创建一个 HeroWalker 对象 hero，并将其设置到场景对象 sobj 中。

7. 设置英雄的名称 name、称号 badge 和名称颜色 name_color。如果有称号 title，则设置称号并更新自己的称谓信息。

8. 如果全局数据中设置了显示幻影 global_data.hero_show_phantom，则将英雄的 need_show_phantom 属性设置为 True。

9. 如果全局数据中设置了英雄的奔跑速度 global_data.hero_run_speed，则将英雄的 ani.run_speed 设置为该值。

10. 设置英雄的照片 hero.photo、时装 global_data.hero_prop.fashiondress、武器装扮 global_data.hero_prop.weapon_dress 和自定义时装数据 global_data.hero_prop.cfashion_data。

11. 如果数据中有商店索引 store_index 和商店深度 store_zdeep，则调用 hero.set_store_trinket_pos(data.store_index, data.store_zdeep) 设置商店饰品位置。

12. 根据一些条件判断是否显示饰品 is_show_trinket 和光环 is_show_halo。

13. 如果需要显示饰品且不在试炼模式下，则根据数据中的饰品信息 data.trinket，调用 hero.dress_trinket.add_trinket(data.trinket) 添加饰品。

14. 如果需要显示光环且不在试炼模式下，则根据数据中的光环信息 data.halo，调用 hero.dress_trinket.add_binfen_effect(data.halo) 添加光环效果。

15. 如果数据中有足迹信息 data.footprint，则调用 hero.dress_trinket.add_footprint(data.footprint) 添加足迹效果。

16. 设置英雄的装饰品强制加载 plist 文件，调用 hero.dress_trinket.set_force_enable_load_plist(True)。

17. 设置英雄的类型为 "英雄"。

18. 如果当前英雄在普通场景中被隐藏，则调用 global_scene.hide_object(hero_id, True) 重新隐藏角色。

19. 最后，触发 SceneEvent().add_obj_to_scene.emit(hero) 事件，将英雄对象添加到场景中。

##### refresh_scene_darkness：地图变色

```python
    def refresh_scene_darkness(self):
        if self.is_new_layer_mgr_type():
            if self._war_scene_layer_mgr is not None:
                self._war_scene_layer_mgr.refresh_scene_darkness()
        else:
            # 添加对2D Scene2DPresenter的明暗度调整功能
            if self._scene2d_presenter is not None and not FORCE_SHOW_3DSCENE:
                dark = getattr(global_scene, "scene_darkness", 0)
                self._scene2d_presenter.change_scene_darkness(dark)
```

1. 首先，通过调用 self.is_new_layer_mgr_type() 方法判断是否使用的新战斗场景模式。

2. 如果是使用的新战斗场景模式：

   检查 self.war_scene_layer_mgr 是否不为 None，即是否使用的新战斗场景模式。
   如果是使用的新战斗场景模式，调用 self._war_scene_layer_mgr.refresh_scene_darkness() 方法刷新战斗场景的明暗度。刷新逻辑如下：

   遍历 self._scene_name_2_layerobj 字典，获取每个场景名称和对应的图层对象，然后从全局场景中获取明暗度值，并将其传递给图层对象的 change_scene_darkness() 方法进行调整。

3. 如果不是使用的新战斗场景模式：

   检查 self.scene2d_presenter 是否不为 None，即是否存在 2D 场景展示器，并且 FORCE_SHOW_3DSCENE 为 False，即不强制显示 3D 场景。
   如果满足条件，则获取全局场景 global_scene 的 scene_darkness 属性值，如果该属性不存在，则默认为 0。
   调用 self.scene2d_presenter.change_scene_darkness(dark) 方法，遍历 self.scene_images 字典中的每个地图底块，获取其材质对象，并设置材质的 "ColorMapDarkness" 和 "EnableColorMap" 属性来实现亮度的调整。将获取到的明暗度值 dark 传递给 2D 场景展示器，以调整场景的明暗度。

##### add_scene_stuff：添加场景特效

根据系统设置来决定是否执行特效物体的添加操作,具体还是走begin_add_scene_stuff这个方法里的逻辑

```python
def begin_add_scene_stuff(scene_id, is_night=False):
    from data.scene_ani.scene_ani_conf import scene_ani_info

    # 清理特效数据
    global_scene.clear_scene_stuff_data()
    # 场景资源id，转为对应的特效id
    scene_id = get_scene_effect_scene_id(scene_id, is_night=is_night)
    # 加载对应场景的配置
    get_scene_ani_conf(scene_id)

    from gcommon.stuff_mgr import StuffMgr

    StuffMgr().add_stuff_list_to_scene(
        scene_ani_info.get(scene_id), group="scene_ani_effect"
    )
    # 加载节日气氛特效
    if global_scene.enable_festival_effect:
        add_festival_scene_stuff(scene_id)
    pass
```

1. 函数接受两个参数：

   scene_id：场景的标识符或特效文件的名称。
   is_night：是否为夜间场景，默认为 False。

2. 从 data.scene_ani.scene_ani_conf 模块中导入 scene_ani_info 变量，该变量可能包含了场景特效的配置信息。

3. 调用 global_scene.clear_scene_stuff_data() 方法清理特效数据，可能是为了确保在添加新特效之前，先清除之前的特效数据。

4. 调用 get_scene_effect_scene_id(scene_id, is_night=is_night) 函数，将场景资源标识符 scene_id 转换为对应的特效标识符，并将结果赋值给 scene_id 变量。这可能是为了根据场景标识符获取对应的特效配置。

5. 调用 get_scene_ani_conf(scene_id) 函数，加载对应场景的特效配置信息。

6. 从 gcommon.stuff_mgr 模块中导入 StuffMgr 类。

7. 创建 StuffMgr 类的实例，并调用其 add_stuff_list_to_scene 方法，将 scene_ani_info.get(scene_id) 获取到的特效物体列表添加到场景中，并指定分组为 "scene_ani_effect"。

8. 如果 global_scene.enable_festival_effect 为 True，表示启用节日气氛特效，则调用 add_festival_scene_stuff(scene_id) 函数，加载节日气氛特效。

### 处理角色瞬移：

协议：s_map_goto_m_81.py

#### 详细步骤：

**协议文件：**s_map_scene_80.py

**协议号：**81

**FMT：**一个列表,定义了协议数据的格式。在这个例子中,有两个字段:x和y,都是INT2类型。表示英雄的坐标值

1. 首先获取当前场景(global_scene)和英雄对象(obj)

2. 如果英雄对象存在,则执行以下操作:

   将英雄对象的网格位置设置为接收到的x和y坐标。
   如果拉回相关的log打印模式为True,则打印调试信息。
   从gcommon.walker_interface导入WalkerAniInterface。
   停止英雄对象的移动动作(WalkerAniInterface.MOVE_ACTION_TAG)。
   根据global_data.enable_auto_path_optimize的值,调用英雄对象的stand方法,可能会强制站立。
   获取英雄对象的导航器(nav),并重新启动导航。

### 游戏场景中播放特效：

#### 详细步骤：

**协议文件：**s_map_effect_88.py

**协议号：**88

**FMT：**定义了协议的数据格式，包括使用者ID、使用对象ID和特效ID。

1. 类方法 create_special_effect 用于创建特殊效果：

   根据目标ID获取对象 obj。如果特效ID在 EFFECT_TABLE 中，则播放对应的音效，并根据特效名称创建特效trinket，设置特效的循环次数、帧速度和自动释放等属性，并设置特效的全局Z级别为最顶层。
   如果特效ID不在 EFFECT_TABLE 中，则播放对应的FMOD音效，并根据特效ID创建特效trinket，设置特效的循环次数、帧速度和自动释放等属性，并设置特效的全局Z级别为最顶层。

2. 类方法 handler 用于处理接收到的协议数据：

​	如果特效ID小于100，则调用 create_special_effect 方法创建特殊效果。如果特效ID大于等于100，则根据目标对象的位置创建场景特效，设置特效的循环次	数、自动释放等属性，并设置特效的全局Z级别为最顶层。播放对应的FMOD音效。如果特效ID在 NO_MASK_EFFECT 列表中，则禁用特效的遮罩。

### 同步队伍信息：

#### 详细步骤：

协议文件：s_map_team_89.py

协议号：89

FMT：定义了协议的数据格式，包括使用者ID、使用对象ID和特效ID。

1. 首先判断是否在战斗中或者是否允许添加玩家,如果是,则直接返回。然后通过decode_net_package函数解码members_data,得到队伍成员列表。
2. 接着通过TeamAppearanceSys().refresh_team_info(data)刷新队伍信息。获取队长ID(leaderid),并根据ID获取对应的对象(obj)。
3. 如果data.flag为1,表示有队伍,则将leaderid添加到队长缓存中,并通过global_walker_mgr.relation_control.add_team添加队伍关系;否则表示解散或暂离队伍,需要移除队伍关系。
4. 如果obj存在,则设置其队伍列表和满员状态。最后根据队长ID检查是否需要请求某些特定地图的附加数据,如攻防战、国战等。

#### 重要逻辑记录：

##### decode_net_package：数据包解码

```python
def decode_net_package(data, fmtlist, offset=0, val=None, tlen=None):
    # fmt的结构是[(key, type, arg), (key, type, arg), ...]
    # 针对硬协议和软协议解析时，如果配置的fmtlist与服务器实际发送的数据长度不一致时，仅解析符合要求的字段，没有发送的字段返回默认值
    if not val:
        val = ArgObj()
    for i in range(len(fmtlist)):
        fmt_pack = fmtlist[i]
        flen = len(fmt_pack)
        # 协议字段解析配置
        # ('photo', INT2),
        # ('name', CHAR_STR, (20, True)),
        if flen == 3:
            key, fmt, arg = fmt_pack
        elif flen == 2:
            key, fmt = fmt_pack
            arg = None
        else:
            raise Exception("package define format err:%r" % fmt_pack)

        # fmt 可以是自定义结构，也可以是标准结构
        if fmt == SKIP_TYPE:
            offset += int(arg)
        elif fmt == TOTAL_LEN_TYPE:
            if tlen is not None:
                val[key] = tlen - offset
        elif fmt == REMAIN_BYTE:
            if tlen is not None:
                val[key] = data[offset:]
                offset = tlen
        elif fmt == ARRAY_TYPE:
            # 需要递归解析 数组类型 # ('members', ARRAY_TYPE, (member_count, INT4))
            array_size, _fmt = arg
            if isinstance(
                array_size, str
            ):  # 如果是字符串，表示拿已经解析的字段值
                array_size = val.get(array_size, None)
            if array_size is None:
                raise Exception(
                    "decode_net_package array size get None %r" % arg
                )
            ret = []
            try:
                for i in range(array_size):
                    # 如果某个字段解析出错,那么offset不往后移，直接返回默认值
                    _val = unpack_from(_fmt, data, offset)
                    offset += calcsize(_fmt)
                    _result = _val[0]
                    if isinstance(_result, bytes):
                        _result = _result.decode("gbk")
                    ret.append(_result)
            except Exception as e:
                err_msg = (
                    "track_protocol:decode_net_package array error: key:%s, fmtlist:%s, unpacked_data:%s\n"
                    % (key, fmtlist, val)
                )
                err_msg += str(e) + "\n"
                err_msg += str(binascii.b2a_hex(data))
                print(err_msg)
                sys.stderr.write(err_msg)
                sys.stderr.write("\n")

            val[key] = ret
        elif (
            fmt == ARRAY_STRUCT
        ):  # ('faction_list', ARRAY_STRUCT, (_cnt, faction_fmt))
            array_size, _fmtlist = arg
            if isinstance(array_size, str):
                array_size = val.get(array_size, None)
            if isinstance(_fmtlist, list):
                val[key] = []

                try:
                    for i in range(array_size):
                        _arr_data = ArgObj()
                        offset, _arr_data = decode_net_package(
                            data, _fmtlist, offset, _arr_data
                        )
                        val[key].append(_arr_data)
                except Exception as e:
                    err_msg = (
                        "track_protocol:decode_net_package struct error: key:%s, fmtlist:%s, unpacked_data:%s\n"
                        % (key, fmtlist, val)
                    )
                    err_msg += str(e) + "\n"
                    err_msg += str(binascii.b2a_hex(data))
                    print(err_msg)
                    sys.stderr.write(err_msg)
                    sys.stderr.write("\n")
            else:
                raise Exception(
                    "decode_net_package array_struct fmtlist type error"
                )

        elif fmt == BYTE_STR:  # 在python3中，这个就是bytes字节串
            str_size = arg[0]
            if isinstance(str_size, str):
                str_size = val.get(str_size, None)
            _tfmt = "%sc" % str_size
            ret = unpack_from(_tfmt, data, offset)
            val[key] = ret[0]
            offset += calcsize(_tfmt)
        elif (
            fmt == CHAR_STR
        ):  # 以\0结尾的字符串，在python3中这个是固定长度的字符串，与bytes做好区分
            str_size = arg[0]
            if isinstance(str_size, str):
                str_size = val.get(str_size, None)
            if str_size == -1:
                # -1表示把剩下的内容作为一个字符串
                # 在解析221软协议的时候有用
                # 这个必须是最后一个数据段了
                if len(arg) > 1 and arg[1] is True:
                    val[key] = mbcs_to_utf8(data[offset:])
                else:
                    val[key] = data[offset:]
                return len(data), val

            # 如果数据长度够，则直接一次性解析,如果不够，则只解析已有的数据
            data_len = len(data)
            unit_len = calcsize(
                "s"
            )  # 虽然是一个字节长度，但是还是calcsize统一处理吧
            end_offset = offset + str_size * unit_len
            if end_offset > data_len:
                # 数据长度不够
                str_size = int((data_len - offset) * 1.0 / unit_len)
                err_msg = (
                    "track_protocol:decode_net_package char_str error, key:%s, str_size:%s fmtlist:%s, unpacked_data:%s\n"
                    % (key, str_size, fmtlist, val)
                )
                err_msg += str(binascii.b2a_hex(data))
                print(err_msg)
                sys.stderr.write(err_msg)
                sys.stderr.write("\n")

            ret_str = ""
            if str_size > 0:
                _tfmt = "%ss" % str_size
                ret = unpack_from(_tfmt, data, offset)
                ret_str = ret[0]
                offset += calcsize(_tfmt)

            if len(arg) > 1 and arg[1] is True:
                val[key] = mbcs_to_utf8(ret_str)
            else:
                val[key] = ret_str

        elif fmt == PREFIX_STR:  # 2字节长度 + 对应长度
            auto_conv_encoding = arg and arg[0] or False
            # 先取出字符串长度
            data_len = len(data)
            end_offset = offset + calcsize(INT2)
            if end_offset > data_len:
                # 数据不够，直接返回
                val[key] = ""
                err_msg = (
                    "track_protocol:decode_net_package prefix_str str_size error, key:%s, fmtlist:%s, unpacked_data:%s"
                    % (key, fmtlist, val)
                )
                err_msg += str(binascii.b2a_hex(data))
                print(err_msg)
                sys.stderr.write(err_msg)
                sys.stderr.write("\n")
                return

            str_size = unpack_from(INT2, data, offset)
            str_size = str_size[0]
            offset += calcsize(INT2)

            # 再取出字符串
            unit_len = calcsize("s")
            end_offset = offset + str_size * unit_len
            if end_offset > data_len:
                # 数据长度不够
                str_size = int((data_len - offset) * 1.0 / unit_len)
                err_msg = (
                    "track_protocol:decode_net_package prefix_str content error, key:%s, str_size:%s fmtlist:%s, unpacked_data:%s"
                    % (key, str_size, fmtlist, val)
                )
                err_msg += str(binascii.b2a_hex(data))
                print(err_msg)
                sys.stderr.write(err_msg)
                sys.stderr.write("\n")

            ret_str = ""
            if str_size > 0:
                _tfmt = "%ss" % str_size
                ret = unpack_from(_tfmt, data, offset)
                ret_str = ret[0]
                offset += calcsize(_tfmt)

            if auto_conv_encoding:
                val[key] = mbcs_to_utf8(ret_str)
            else:
                val[key] = ret_str

        elif fmt == RPC_TYPE:
            _val, offset = decode_luatable(data, offset)
            val[key] = _val
        else:
            # 根据不同的结构解析字符串, int等类型
            try:
                ret = unpack_from(fmt, data, offset)
                val[key] = ret[0]
                offset += calcsize(fmt)
            except Exception as e:
                val[key] = 0
                err_msg = (
                    "track_protocol:decode_net_package normal fmt error, key:%s, fmt:%s, fmtlist:%s, unpacked_data:%s\n"
                    % (key, fmt, fmtlist, val)
                )
                err_msg += str(e) + "\n"
                err_msg += str(binascii.b2a_hex(data))
                print(err_msg)
                sys.stderr.write(err_msg)
                sys.stderr.write("\n")

    return offset, val

```


各个功能函数的作用：

* decode_net_package(data, fmtlist, offset=0, val=None, tlen=None)：

功能：将二进制数据按照指定的格式解析成Python数据结构。
参数：
data：待解析的二进制数据。
fmtlist：格式列表，指定了每个字段的解析方式。
offset：解析的起始偏移量。
val：用于存储解析结果的对象。
tlen：数据的总长度。
返回值：解析后的偏移量和解析结果。

* decode_luatable(data, offset)：

功能：解析Lua表格式的数据。
参数：
data：待解析的二进制数据。
offset：解析的起始偏移量。
返回值：解析后的数据和偏移量。

* encode_luatable(data, obuf)：

功能：将Python数据结构编码成Lua表格式的二进制数据。
参数：
data：待编码的Python数据结构。
obuf：用于存储编码结果的缓冲区。

* pack_by_data_fmtlist(obuf, data, fmtlist)：

功能：根据指定的格式列表将Python数据结构打包成二进制数据。
参数：
obuf：用于存储打包结果的缓冲区。
data：待打包的Python数据结构。
fmtlist：格式列表，指定了每个字段的打包方式。

* encode_net_package(protocol, data, fmtlist, obuf=None)：

功能：将Python数据结构按照指定的格式打包成网络数据包。
参数：
protocol：协议号。
data：待打包的Python数据结构。
fmtlist：格式列表，指定了每个字段的打包方式。
obuf：用于存储打包结果的缓冲区，如果为None则创建一个新的缓冲区。
返回值：打包后的二进制数据。

* encode_rpc_net_package(protocol, data, fmtlist)：

功能：将Python数据结构按照指定的格式打包成RPC网络数据包。
参数：
protocol：协议号。
data：待打包的Python数据结构。
fmtlist：格式列表，指定了每个字段的打包方式。
返回值：打包后的二进制数据。



1. 如果没有提供val对象，则创建一个新的ArgObj对象用于存储解析结果。

2. 遍历fmtlist中的每个格式定义：

   如果格式定义长度为3，则解包为key、fmt和arg。
   如果格式定义长度为2，则解包为key和fmt，arg为None。
   否则抛出异常，表示格式定义错误。

3. 根据不同的fmt类型进行解析：

   如果fmt为SKIP_TYPE，则跳过指定长度的字节。
   如果fmt为TOTAL_LEN_TYPE，则将剩余数据长度存储在val对象的对应key中。
   如果fmt为REMAIN_BYTE，则将剩余数据存储在val对象的对应key中。
   如果fmt为ARRAY_TYPE，则递归解析数组类型的数据。
   如果fmt为ARRAY_STRUCT，则递归解析结构体数组类型的数据。
   如果fmt为BYTE_STR，则解析指定长度的字节串。
   如果fmt为CHAR_STR，则解析以\0结尾的字符串。
   如果fmt为PREFIX_STR，则解析以2字节长度开头的字符串。
   如果fmt为RPC_TYPE，则调用decode_luatable函数解析Lua表格式的数据。
   否则，根据fmt解析对应类型的数据，如整数、字符串等。

4. 在解析过程中，如果出现异常或数据长度不足，会输出错误信息并返回默认值。

5. 解析完成后，返回更新后的偏移量offset和存储解析结果的val对象

##### check_guozhan_leader：检查国战

由于一些特殊地图需要添加特定地图的附加数据，这里以国战为例梳理整个添加附加数据的流程。

1. 如果同时满足以下两个条件：
   - 当前场景为国战场景（global_scene.scene_id in guozhan_map）
   - 当前玩家为国战的领袖（leader == global_data.hero_prop.get("id")）
2. 则调用rpc_call_server("request_national_war_addon")函数，向服务器发起请求获取国战的附加信息。

## 地图块：
场景中的地图是由一个个地图块组成每一个地图快都是一个sprite,单个地图快的大小和`CELLSIZE`这个常量有关，现在是每个地图块20个像素左右。然后场景都继承scene_base，

### 地图块：

MapBlcok：

```python
class MapBlock(object):
    def __init__(self, target=None, scene_id=None):
        super(MapBlock, self).__init__()
        self._img_id = None
        self._sprite_holder = None
        self._img = None
        self._mask_img = None
        self._target = target
        self._weather_effect = None
        self._scene_id = scene_id
        self._block_img_list = []  # sunshine 启动后再场景编辑器里面可以显示阻挡区域 luhengsi 2022.1.26

        self._px = None
        self._py = None

    def __str__(self):
        return "MapBlock %s" % str(self._img_id)

    def load(self, img_id, x, y, is_async=True, force_reload=False):
        if self._img_id == img_id and not force_reload:
            logger.debug("load same img_id %s" % img_id)
            self._sprite_holder.set_pixel_pos(x, y)
            return self._img
        #
        scene = global_scene
        if self._sprite_holder is None:
            self._sprite_holder = create_sprite_holder()
            if global_data.enable_nxgui_to_plane:
                self._sprite_holder.set_nxgui_to_plane(True)  # nxgui旋转摊平
                self._sprite_holder.set_global_z_level(
                    0
                )  # 引擎的PlaceAvatarInWorld会把cocos坐标映射会y=0平面的model坐标
            else:
                self._sprite_holder.set_global_z_level(
                    get_global_z_level_by_z_order(G_PC_Z_ORDER_SCENE_MAP)
                )
            sprite_canvas = self._sprite_holder.canvas
            sprite_canvas.entity.name = "MapBlock %s" % str(img_id)
            sprite_canvas.set_render_group(const.RENDER_GROUP_SCENE_MAP)
            self._img = sprite_canvas.create_child_widget(NeoxImage)
            self._img.set_pivot(0.0, 0.0)
            self._img.set_local_zorder(1)
            self._mask_img = sprite_canvas.create_child_widget(NeoxImage)
            self._mask_img.set_pivot(0.0, 0.0)
            self._mask_img.set_local_zorder(2)

            if global_data.enable_nxgui_to_plane:
                # 平铺后的地图，开启深度测试（不写深度，因为目前npc这种立起来的nxgui读深度了，否则会跟地表有穿插）
                self._img.set_ztest_enable(True)
                # self._img.set_zwrite_enable(True)

                # 优先渲染地图层
                self._img.set_render_priority(
                    const.RENDER_GROUP_SCENE_MAP_PRIORITY
                )

            #
            if self._target is None:
                # 地图块加载到场景
                scene.attach_sprite_holder(self._sprite_holder, 0)
            else:
                # 地图块加载到指定对象上
                self._target.addChild(self._sprite_holder.sprite, 0)

        scene_id = self._scene_id or scene.res_id

        # 天气系统的场景资源转换处理
        is_enable_weather = WeatherMgr().is_weather_or_night(scene_id)
        if is_enable_weather:
            scene_id = WeatherMgr().get_weather_scene_id(scene_id)
        #
        scn_img_path = com_path.get_scene_img_path(scene_id, img_id)
        scn_mask_img_path = com_path.get_scene_mask_img_path(scene_id, img_id)

        if is_async:
            self._img.set_texture_async(
                scn_img_path, priority=const.MAP_ASYNC_IO_PRIORITY
            )
        else:
            self._img.set_texture(scn_img_path)

        # 调试地图遮罩图, 只有在新遮罩模式下才生效
        is_debug_map = global_data.is_map_mask_debug and scene.is_new_mask
        self._img.map_mask_affected = is_debug_map
        self._img.hero_mask_mode = is_debug_map
        self._img.map_mask_debug = is_debug_map

        if global_data.enable_all_mask and not scn_mask_img_path:
            scn_mask_img_path = global_data.default_mask_path

        if global_data.enable_new_mask and scn_mask_img_path:
            self._mask_img.set_texture_async(scn_mask_img_path)
            self._mask_img.visible = True
            mask_rt_show = True
            self._mask_img.show_ext_technique(
                render.EXT_TECH_RENDER_TO_RT, mask_rt_show
            )
            self._mask_img.show_ext_technique(
                render.EXT_TECH_DEAFAULT, not mask_rt_show
            )
            self._mask_img.get_material().set_custom_data(
                const.CUSTOM_RT_NAME, const.MapMaskAndLight_NAME
            )
            self._mask_img.map_mask_affected = False

            if global_data.enable_all_mask:
                # 如果要关掉宏，只能重进场
                self._mask_img.get_material().set_macro(
                    const.ALL_MAP_MASK_MODE_MACRO, True
                )
                if not global_data.default_mask_path:
                    global_data.default_mask_path = scn_mask_img_path

            # 加载block里面的mask
            if scene.is_new_mask:
                scene.mask_loader.load_block(img_id)
        else:
            self._mask_img.visible = False

        self._sprite_holder.set_pixel_pos(x, y)
        self._img_id = img_id
        self._px = x
        self._py = y
        self.set_map_macro()
        self.load_color_map()
        self.create_block_imgs(x, y)
        from gcommon.event.scene_event import SceneEvent

        SceneEvent().on_map_block_load.emit(
            img_id, x, y, TILE_WIDTH, TILE_HEIGHT
        )
        # 添加天气效果
        if is_enable_weather:
            if self._weather_effect:
                self._weather_effect.unload()
            self._weather_effect = WeatherMapEffect(self, scene_id)
            self._weather_effect.load(img_id, x, y, is_async=True)
        #
        return self._img

    def unload(self):
        x, y = None, None
        if self._sprite_holder is not None:
            x, y = self._sprite_holder.get_pixel_pos()
            self._sprite_holder.release()
            self._sprite_holder = None
        self._img = None
        self._mask_img = None
        img_id = self._img_id
        self._img_id = None
        self._block_img_list = []
        if x and y:
            from gcommon.event.scene_event import SceneEvent

            SceneEvent().on_map_block_unload.emit(
                img_id, x, y, TILE_WIDTH, TILE_HEIGHT
            )
        if self._weather_effect:
            self._weather_effect.unload()
            self._weather_effect = None
        pass

    def get_weather_effect(self):
        # 获取天气组件
        return self._weather_effect

    def set_pixel_pos(self, x, y):
        self._sprite_holder.set_pixel_pos(x, y)
        pass

    def set_visible(self, is_visible):
        self._sprite_holder.model.visible = is_visible
        pass

    def set_map_macro(self):
        img_material = self._img.get_material()
        img_material.set_macro(XY2_RENDER_MAP_MACRO, True)

    def load_color_map(self):
        img_material = self._img.get_material()
        img_material.set_macro(XY2_DARKNESS_MACRO, XY2_DARKNESS_STATE)
        img_material.set_texture(
            XY2_DARKNESS_COOLER_TEX, global_scene.cooler_color_map_obj
        )
        img_material.set_texture(
            XY2_DARKNESS_WARMER_TEX, global_scene.warmer_color_map_obj
        )

        self.update_dark_attr()

    def update_dark_attr(self):
        dark = 0
        img_material = self._img.get_material()
        enable_change_color = game_setting_flag("SceneChangeColor")

        if enable_change_color:
            if getattr(global_scene, "color_map_load_state", False):
                dark = getattr(global_scene, "scene_darkness", 0)
            img_material.set_float("ColorMapDarkness", float(dark))
        img_material.set_float("EnableColorMap", float(enable_change_color))

    def force_load_texture(self):
        if (
            self._img
            and self._img.texture_path
            and not self._img.is_texture_valid
        ):
            self._img.set_texture(self._img.texture_path)

    def check_in_scene_view(self, scene_view_rect=None):
        x, y = self._sprite_holder.get_pixel_pos()
        rect = (x, y + TILE_HEIGHT, x + TILE_WIDTH, y)
        if scene_view_rect is None:
            scene_view_rect = global_scene.get_view_rect_point()
        return global_scene.check_rect_overlap(rect, scene_view_rect)

    def create_block_imgs(self, x, y):
        if (
            not global_data.is_editor_scene_block_debug
            and not global_data.is_editor_scene_jump_debug
            and not global_data.is_editor_scene_stall_debug
        ):
            return

        scene = global_scene
        if not hasattr(scene, "_is_ready") or not scene._is_ready:
            return

        if len(self._block_img_list) > 0:
            # 已经加载过了
            return

        # x, y = self._sprite_holder.get_pixel_pos()
        gx, gy = (
            int((x + CELLSIZE - 1) / CELLSIZE),
            int((y + CELLSIZE - 1) / CELLSIZE),
        )
        offsetx = gx * CELLSIZE - x
        offsety = gy * CELLSIZE - y
        w = int((TILE_WIDTH + CELLSIZE - 1) / CELLSIZE)
        h = int((TILE_HEIGHT + CELLSIZE - 1) / CELLSIZE)
        sprite_canvas = self._sprite_holder.canvas
        for j in range(0, h):
            for i in range(0, w):
                bx, by = int(gx + i), int(gy + j)
                if bx * CELLSIZE >= int(
                    x + TILE_WIDTH
                ) or by * CELLSIZE >= int(y + TILE_HEIGHT):
                    continue
                # tag = scene.path_finder.get_block(bx, by)
                tag = scene.debug_get_cell_val(bx, by)
                res_path = None
                if tag > 0:
                    if global_data.is_editor_scene_block_debug and tag == 1:
                        res_path = "res2d/scene/block_debug_red.png"
                    elif global_data.is_editor_scene_jump_debug and tag == 2:
                        res_path = "res2d/scene/block_debug_green.png"
                    elif global_data.is_editor_scene_stall_debug and tag == 3:
                        res_path = "res2d/scene/block_debug_yellow.png"

                elif (
                    global_data.is_editor_scene_block_debug
                    and scene.is_block(bx, by)
                ):
                    res_path = "res2d/scene/block_debug_none.png"

                if res_path:
                    block_img = sprite_canvas.create_child_widget(NeoxImage)
                    block_img.set_pivot(0.0, 0.0)
                    cx, cy = i * CELLSIZE + offsetx, j * CELLSIZE + offsety
                    block_img.set_position(cx, cy, 2)
                    block_img.set_local_zorder(2)
                    block_img.set_texture_async(res_path)
                    self._block_img_list.append([block_img, cx, cy])

    def reload(self):
        self.load(self._img_id, self._px, self._py, force_reload=True)
```



#### 详细步骤如下：

1. load方法用于加载地图块的图像资源。它接受几个参数，如img_id（图像ID）、x和y（地图块的位置坐标）、is_async（是否异步加载）和force_reload（是否强制重新加载）。在这个方法中，会根据传入的参数加载地图块的图像资源，并设置相关属性。
2. unload方法用于卸载地图块的资源。它会释放_sprite_holder(这个图是3d还是2d的)、_img、_mask_img等对象，并清空一些属性。
3. get_weather_effect方法用于获取地图块的天气效果组件。

4. set_pixel_pos方法用于设置地图块的像素位置。

5. set_visible方法用于设置地图块的可见性。

6. set_map_macro方法用于设置地图块的材质宏定义。

7. load_color_map方法用于加载地图块的颜色贴图。

8. update_dark_attr方法用于更新地图块的黑暗属性。

9. force_load_texture方法用于强制加载地图块的纹理。

10. check_in_scene_view方法用于检查地图块是否在场景视图范围内。

11. create_block_imgs方法用于创建地图块的调试图像，用于在编辑器中显示阻挡区域、跳跃区域和摊位区域。

12. reload方法用于重新加载地图块的资源。

#### 重点逻辑记录：

##### load：

作用：加载地图块的图像资源。

1. 首先判断传入的img_id是否与当前的_img_id相同，并且force_reload参数为False。如果条件满足，说明要加载的图像资源与当前已加载的相同，无需重新加载。此时只需要更新地图块的位置坐标即可，然后直接返回当前的_img对象。

2. 如果需要加载新的图像资源，首先获取全局场景对象global_scene。

3. 如果_sprite_holder为None，说明当前地图块还没有创建精灵持有者对象，需要进行初始化：

   1. 调用create_sprite_holder()函数创建一个新的精灵持有者对象。返回SpriteHolderScene3D或者SpriteHolderScene2D

   2. 根据全局配置global_data.enable_nxgui_to_plane的值，设置精灵持有者的属性，如是否将nxgui旋转摊平（具体可以查看set_parallel_plane()这个接口里面的实现），以及设置全局z级别。

      `通过set_parallel_plane()这个方法，对象被旋转到平行于y=0平面的位置，并且在y轴上进行了缩放补偿，以保持视觉上的原始比例。这种操作通常用于将对象放置在地面上，使其与地面平行，并且保持正确的视觉效果。`

   3. 获取精灵持有者的画布对象sprite_canvas，并设置其名称和渲染组。
      在画布上创建两个子部件：_img表示地图块的图像，_mask_img表示地图块的遮罩图像。设置它们的锚点、局部z顺序等属性。
      如果启用了nxgui平铺模式，还需要设_img的深度测试和渲染优先级。_

   4. _根据_target的值，决定将地图块加载到场景中还是加载到指定的目标对象上。】

4. 获取场景IDscene_id，优先使用_scene_id，如果为None则使用全局场景的res_id(资源id)。

5. 进行天气系统的场景资源转换处理，根据场景ID判断是否启用天气效果，如果启用，则获取对应的天气场景ID。

6. 根据场景ID和图像ID，获取地图块的图像路径scn_img_path和遮罩图像路径scn_mask_img_path。

7. 根据is_async参数的值，决定是异步加载还是同步加载地图块的图像资源。

8. 根据全局配置和场景属性，设置地图块图像的调试属性，如是否受遮罩影响、是否启用英雄遮罩模式等。

9. 如果启用了全局遮罩且没有指定遮罩图像路径，则使用默认的遮罩路径。

10. 如果启用了新的遮罩模式且指定了遮罩图像路径，则加载遮罩图像资源，并设置相关属性，如可见性、渲染技术、材质宏定义等。如果启用了全局遮罩，还需要设置默认的遮罩路径。

11. 如果没有启用新的遮罩模式或没有指定遮罩图像路径，则隐藏遮罩图像。

12. 更新地图块的位置坐标，并保存当前的图像ID和位置坐标。

13. 调用一些辅助方法，如设置地图宏、加载颜色贴图、创建调试图像等。

14. 发送地图块加载事件，通知相关系统地图块已加载完成。

15. 如果启用了天气效果，则创建或更新地图块的天气效果组件_weather_effect，并异步加载天气效果资源。_

16. _最后返回加载完成的地图块图像对象_img

##### unload：

作用：加载地图块的图像资源。

1. 首先将变量x和y初始化为None，用于存储地图块的像素坐标。

2. 如果self._sprite_holder不为None，表示当前地图块有关联的精灵持有者（sprite holder）：

   通过调用self._sprite_holder.get_pixel_pos()获取地图块的像素坐标，并将结果赋值给x和y。
   调用self._sprite_holder.release()释放精灵持有者占用的资源。
   将self._sprite_holder设置为None，表示已经释放了精灵持有者。_

3. 将self._img和self._mask_img设置为None，表示清空地图块的图像和遮罩图像。

4. 将self._img_id的值赋给img_id，然后将self._img_id设置为None，表示清空地图块的图像ID。

5. 将self._block_img_list设置为空列表[]，表示清空地图块的图像列表。

6. 如果x和y都不为None，表示地图块有有效的像素坐标：

   从gcommon.event.scene_event模块中导入SceneEvent类。
   通过SceneEvent().on_map_block_unload.emit()发送地图块卸载的事件，传递的参数包括img_id、x、y、TILE_WIDTH和TILE_HEIGHT，表示卸载的地图块的图像ID、像素坐标以及地图块的宽度和高度。

7. 如果self._weather_effect不为None，表示地图块有关联的天气效果：

   调用self._weather_effect.unload()卸载天气效果。
   将self._weather_effect设置为None，表示已经卸载了天气效果。

### 地图块管理：

负责管理地图块的加载、卸载、更新和显示。

坑点：多个地方复用了，故这个管理者并不是单例

MapBlockMgr：

```python
class MapBlockMgr(object):
    def __init__(self):
        super(MapBlockMgr, self).__init__()
        self.valid_blocks = {}
        self.invalid_blocks = []
        self.max_cnt = 0
        self.width_cnt = 0
        self.height_cnt = 0
        self.start_img_idx = -1
        self.target = (
            None  # 地图块管理跟场景分离,实现可在界面上加载地图某块区域
        )
        self.scene_id = None  # 地图块管理跟场景分离,指定场景
        self.is_all_texture_valid = (
            True  # 记录当前地图块的纹理是否都加载完成了
        )
        self.current_col_count = 0
        self.current_row_count = 0
        self.current_view_map_tile_ids = set()

    def on_finalize(self):
        self.clear()

    def clear(self):
        self.invalid_blocks.extend(iter(self.valid_blocks.values()))
        self.valid_blocks = {}
        list(map(lambda x: x.unload(), self.invalid_blocks))
        self.invalid_blocks = []
        self.max_cnt = 0
        self.width_cnt = 0
        self.height_cnt = 0
        self.start_img_idx = -1
        self.target = None
        self.scene_id = None
        self.current_col_count = 0
        self.current_row_count = 0
        self.current_view_map_tile_ids.clear()

    def set_target(self, target, scene_id):
        self.target = target
        self.scene_id = scene_id

    def resize(self, w, h, clear_block=True):
        # 通常resize会发生在场景切换
        # resize 还有在缩放的时候也会做
        ocnt = self.max_cnt
        ncnt = w * h
        if clear_block:
            list(
                map(
                    lambda x: x.unload() or self.invalid_blocks.append(x),
                    iter(self.valid_blocks.values()),
                )
            )

        if ocnt > ncnt:
            # 释放多余的
            del self.invalid_blocks[ncnt:]
        elif ocnt < ncnt:
            list(
                map(
                    lambda x: self.invalid_blocks.append(
                        MapBlock(self.target, self.scene_id)
                    ),
                    range(ocnt, ncnt),
                )
            )
        self.max_cnt = ncnt
        self.width_cnt = w
        self.height_cnt = h
        self.start_img_idx = -1
        self.current_col_count = 0
        self.current_row_count = 0
        # print len(self.invalid_blocks)

    # 这里要判断到底要更新多少个，不一定是全更新的
    def update_view(
        self,
        block_x,
        block_y,
        img_start_idx,
        pitch,
        col_count,
        row_count,
        force_update=False,
        is_async=True,
    ):
        # block_x, block_y 表示首个地图块在地图中的坐标
        # img_start_idx 表示左上角一个图片的下标
        # pitch: cnt_x_tile 一行对应的地图块个数
        # 这里其实可以计算出来需要多少块的，这个函数更新当前需要显示的底图块以及删除一些不需要显示的块
        if (
            not force_update
            and self.start_img_idx == img_start_idx
            and self.current_col_count == col_count
            and self.current_row_count == row_count
            and global_scene.prev_scene_scale == global_scene.scene_scale
        ):
            return

        self.start_img_idx = img_start_idx
        self.current_col_count = col_count
        self.current_row_count = row_count
        pending_image_list = []
        image_map = {}

        # scene_x, scene_y = global_scene._view_org_x, global_scene._view_org_y
        # map(lambda x: x.setVisible(False), self.valid_blocks.itervalues())
        # print 'add map ==================='
        # print block_x, block_y, img_start_idx, pitch, col_count, row_count
        current_view_map_tile_ids = self.current_view_map_tile_ids
        current_view_map_tile_ids.clear()
        for row in range(row_count):
            py = block_y - row * TILE_HEIGHT
            for col in range(col_count):
                # 计算地图块序号id
                img_id = int(img_start_idx + row * pitch + col)

                current_view_map_tile_ids.add(img_id)
                # 是否已加载过
                img = self.valid_blocks.pop(img_id, None)
                px = block_x + col * TILE_WIDTH

                if img:
                    # print img_id, px, py
                    img.set_pixel_pos(px, py)
                    image_map[img_id] = img
                    img.set_visible(True)
                else:
                    # 还没加载
                    pending_image_list.append((img_id, px, py))

        if len(pending_image_list) > 1:
            center_px = block_x + col_count / 2 * TILE_WIDTH
            center_py = block_y - row_count / 2 * TILE_HEIGHT

            def cmp_key(elem):
                return abs(elem[1] - center_px) + abs(elem[2] - center_py)

            pending_image_list.sort(key=cmp_key)

        # 清空原来的有效块
        # print self.valid_blocks.keys()
        for sid, img in self.valid_blocks.items():
            if sid not in image_map:
                # 需要删除
                img.unload()
                self.invalid_blocks.append(img)
        # print 'clean valid_blocks*****************************************************'
        self.valid_blocks = image_map
        # print len(pending_image_list)
        # print len(self.invalid_blocks)
        if pending_image_list:
            for _img_id, _x, _y in pending_image_list:
                if len(self.invalid_blocks) <= 0:
                    # import traceback
                    # traceback.print_stack()
                    # print col_count * row_count
                    # print self.max_cnt
                    # print len(self.valid_blocks), len(image_map)
                    break
                iobj = self.invalid_blocks.pop()
                # print 'load new img ========================================'
                # print _img_id, _x, _y
                if iobj.load(_img_id, _x, _y, is_async):
                    if is_async:
                        self.is_all_texture_valid = False
                    image_map[_img_id] = iobj
                    iobj.set_visible(True)
                else:
                    # print 'load fail==================================='
                    self.invalid_blocks.append(iobj)

        self.valid_blocks = image_map

    def get_valid_map_blocks(self):
        # 获取视野中显示的地图块
        return self.valid_blocks

    def check_valid_blocks_texture(
        self, only_check_in_sight=True, force_load_in_sight=False
    ):
        if self.is_all_texture_valid and not force_load_in_sight:
            return True

        self.is_all_texture_valid = False
        has_map_invalid = False
        scene_view_rect = global_scene.get_view_rect_point()

        # 新增同步加载的数量与时间统计
        force_load_texture_count = 0
        cur_time = 0

        if force_load_in_sight:
            left, top, right, bottom = scene_view_rect
            padding = 20
            scene_view_rect = (
                left - padding,
                top + padding,
                right + padding,
                bottom - padding,
            )
            import time

            cur_time = time.time()

        for item in self.valid_blocks.values():
            if not item._img.is_texture_valid:
                insight = item.check_in_scene_view(scene_view_rect)
                if force_load_in_sight:
                    if insight:
                        item.force_load_texture()
                        force_load_texture_count += 1
                    else:
                        has_map_invalid = True
                else:
                    if only_check_in_sight:
                        if insight:
                            return False
                    else:
                        return False

        if not has_map_invalid:
            self.is_all_texture_valid = True

        if force_load_in_sight and force_load_texture_count > 0:
            import time

            delta_time = time.time() - cur_time
            if delta_time > 0.005:
                logger.debug(
                    "force load map texture, count: %s, time: %s"
                    % (force_load_texture_count, delta_time)
                )

        return True

    def check_update_color_map(self):
        list(
            map(
                lambda x: x.update_dark_attr(),
                iter(self.valid_blocks.values()),
            )
        )

    # 以当前已加载地图为中心，额外预载一圈地图纹理，加速响应
    def preload_extra_map_textures(self):
        scene = global_scene

        scene_id = self.scene_id or scene.res_id

        from gcommon.dutils.scene_utils import get_preload_map_idx_list

        idx_list = get_preload_map_idx_list(
            self.start_img_idx, self.width_cnt, self.height_cnt, 1
        )
        if idx_list is None:
            return

        # 空回调，避免log
        def cb(_):
            pass

        for id in idx_list:
            if id not in self.valid_blocks:
                scn_img_path = com_path.get_scene_img_path(scene_id, id)
                render.texture(
                    scn_img_path,
                    async_priority=game3d.ASYNC_LOW,
                    async_callback=cb,
                )

    def show_block_imgs(self):
        if (
            not global_data.is_editor_scene_block_debug
            and not global_data.is_editor_scene_jump_debug
            and not global_data.is_editor_scene_stall_debug
        ):
            return
        for item in self.valid_blocks.values():
            x, y = item._sprite_holder.get_pixel_pos()
            item.create_block_imgs(x, y)

    def reload_all_block_img(self):
        for item in self.valid_blocks.values():
            if item and hasattr(item, "reload"):
                item.reload()

```

#### 详细步骤如下：

1. _init__方法是类的构造函数，用于初始化MapBlockMgr对象的属性。

   valid_blocks是一个字典，用于存储有效的地图块。
   invalid_blocks是一个列表，用于存储无效的地图块。
   max_cnt表示最大地图块数量。
   width_cnt和height_cnt表示地图块的宽度和高度计数。
   start_img_idx表示起始图像索引。
   target和scene_id用于地图块管理与场景的分离。
   is_all_texture_valid表示当前地图块的纹理是否都加载完成。
   current_col_count和current_row_count表示当前列数和行数。
   current_view_map_tile_ids是一个集合，用于存储当前视图中的地图块ID

2. on_finalize方法用于在对象被销毁时进行清理操作，调用clear方法

3. clear方法用于清空MapBlockMgr对象的属性。

   将valid_blocks中的地图块移动到invalid_blocks中。
   调用每个无效地图块的unload方法进行卸载。
   重置各个属性的值。

4. set_target方法用于设置target和scene_id属性。

5. resize方法用于调整地图块的大小。

   根据新的宽度和高度计算新的地图块数量ncnt。
   如果clear_block为True，则将valid_blocks中的地图块卸载并移动到invalid_blocks中。
   如果原有地图块数量大于新的地图块数量，则删除多余的无效地图块。
   如果原有地图块数量小于新的地图块数量，则创建新的MapBlock对象并添加到invalid_blocks中。
   更新max_cnt、width_cnt、height_cnt等属性的值。

6. update_view方法用于更新当前视图中的地图块。

   根据传入的参数计算需要更新的地图块范围。
   遍历需要更新的地图块，如果已经加载过，则更新其位置；如果还没有加载，则将其添加到待加载列表中。
   对待加载列表进行排序，优先加载距离视图中心更近的地图块。
   清空原有的有效地图块，将不需要显示的地图块卸载并移动到无效地图块列表中。
   从无效地图块列表中取出地图块，调用其load方法进行加载，并将加载成功的地图块添加到有效地图块字典中。

7. get_valid_map_blocks方法用于获取当前视图中显示的有效地图块。

8. check_valid_blocks_texture方法用于检查有效地图块的纹理是否加载完成。

   如果所有地图块的纹理都已加载完成，则返回True。
   否则，遍历有效地图块，检查其纹理是否加载完成，如果未加载完成，则根据参数的设置进行处理：
   	如果only_check_in_sight为True，则只检查视野内的地图块，如果视野内有未加载完成的纹理，则返回False。
   	如果force_load_in_sight为True，则强制加载视野内的地图块纹理，并统计加载的数量和时间。
   如果所有地图块的纹理都加载完成，则将is_all_texture_valid设置为True。

   遍历有效地图块，调用其update_dark_attr方法更新颜色属性。

9. check_update_color_map方法用于检查并更新地图块的颜色映射。

10. preload_extra_map_textures方法用于预加载额外的地图纹理，加速响应。

    根据当前加载的地图块的起始索引、宽度和高度，计算需要预加载的地图块索引列表。
    遍历预加载的地图块索引，如果该地图块未加载，则异步加载其纹理。

11. show_block_imgs方法用于显示地图块的图像，用于调试目的。

    如果满足调试条件，则遍历有效地图块，调用其create_block_imgs方法创建并显示地图块图像。

12. reload_all_block_img方法用于重新加载所有地图块的图像。

    遍历有效地图块，如果地图块具有reload方法，则调用该方法重新加载地图块图像。

## 场景加载：

方法名：scene_base中的load_scene方法

负责加载和初始化场景，包括处理夜间资源模拟、设置图层参数、发送场景切换事件、检查多层级场景、初始化地图、加载背景音乐、初始化阻挡和光照信息、处理玩家名称可见性变化、生成触发器索引列表以及创建和附加地图空间根节点等操作。



```python
    def load_scene(self, scene_id, look_center_pos=None):
        # 场景初始化
        # 这里需要计算真正的场景号和场景名
        ret, res_id = is_night_res_simulation(scene_id)
        if ret:
            self._real_scene_id = res_id
            self._night_scene_res = True
        else:
            self._real_scene_id = get_scene_res_id(scene_id)
            weather_res_id = get_weather_res_id(scene_id)
            self._night_scene_res = self.is_night and weather_res_id > 0

        if global_data.is_map_mask_debug:
            logger.info(
                "load_scene, scene_id=%s, real_scene_id=%s"
                % (self._scene_id, self._real_scene_id)
            )

        self.set_layer_runtime_params("res_id", self.res_id)

        # 准备开始切换场景
        from gcommon.event.scene_event import SceneEvent

        SceneEvent().before_load_scene.emit()
        # 检查是否是多层级
        self.check_multi_layer()

        # 如果相机处于手动模式的同时跳转场景，那么自动恢复跟随模式
        if global_data.camera_move_manual:
            global_data.camera_move_manual = False
            self.enable_scene_follow(True)

        self.init_map(self.res_id, look_center_pos)

        # 加个简单的背景音乐播放功能吧，直接用场景配置的背景音乐
        self.load_scene_background_music(scene_id)

        # 从地图中初始化阻挡信息到寻路模块
        self.init_block_from_map()
        self.init_light_from_map()
        self.on_player_name_visible_change()
        self.gen_cur_scene_trigger_index_list()

        #
        self.map_space_root = create_sprite_holder()
        self.attach_sprite_holder(self.map_space_root)
        self.map_space_root.set_pixel_pos(0, 0)
```

### 详细步骤如下

1. 首先根据传入的scene_id参数判断是否需要进行夜间资源模拟：

   调用is_night_res_simulation函数，传入scene_id，返回一个元组(ret, res_id)。
   如果ret为True，表示需要进行夜间资源模拟，将res_id赋值给self._real_scene_id，并将self._night_scene_res设置为True。
   如果ret为False，表示不需要进行夜间资源模拟，调用get_scene_res_id函数获取真正的场景资源ID，并赋值给self._real_scene_id。同时，调用get_weather_res_id函数获取天气资源ID，如果天气资源ID大于0且当前为夜间，则将self._night_scene_res设置为True。

2. 如果global_data.is_map_mask_debug为True，表示开启了地图遮罩调试模式，输出场景ID和真实场景ID的日志信息。

3. 调用set_layer_runtime_params方法，设置图层的运行时参数"res_id"为当前场景的资源ID。

4. 从gcommon.event.scene_event模块中导入SceneEvent类，并发送before_load_scene事件，表示准备开始切换场景。

5. 调用check_multi_layer方法，检查是否为多层级场景。

6. 如果全局变量global_data.camera_move_manual为True，表示相机处于手动模式，在跳转场景时自动恢复为跟随模式：

   将global_data.camera_move_manual设置为False。调用enable_scene_follow方法，传入True，启用场景跟随。

7. 调用init_map方法，传入当前场景的资源ID和look_center_pos参数，初始化地图。

8. 调用load_scene_background_music方法，传入scene_id，加载场景的背景音乐。

9. 调用init_block_from_map方法，从地图中初始化阻挡信息到寻路模块。

10. 调用init_light_from_map方法，从地图中初始化光照信息。

11. 调用on_player_name_visible_change方法，处理玩家名称的可见性变化。

12. 调用gen_cur_scene_trigger_index_list方法，生成当前场景的触发器索引列表。

13. 创建一个名为map_space_root的精灵持有者（sprite holder），并调用attach_sprite_holder方法将其附加到场景中。

14. 设置map_space_root的像素位置为(0, 0)。

### 重点逻辑记录

init_map：初始化地图

负责初始化地图，包括设置视域范围、获取场景信息、计算瓦片数量和网格数量、加载遮罩数据、初始化多层对象、创建背景层、设置视点位置以及预加载地图纹理。

```python
    def init_map(self, scene_id, look_center_pos=None):
        from xy2reader import NewMaskLoader

        # 设置视域范围矩阵
        self.set_view_limit_rect(
            cc.Rect(0, 0, self._view_width, self._view_height)
        )
        mgr = self

        # 场景参数(实际场景像素宽、高)
        self._scene_name, sw, sh = mgr.get_scene_info(self.scene_id)

        if sw and sh:
            self._w_scene, self._h_scene = sw, sh
            self.cnt_x_tile = int(ceil(sw * 1.0 / TILE_WIDTH))
            self.cnt_y_tile = int(ceil(sh * 1.0 / TILE_HEIGHT))
            self._grid_col = int(ceil(self._w_scene * 1.0 / CELLSIZE))
            self._grid_row = int(ceil(self._h_scene * 1.0 / CELLSIZE))

            # 最边缘的tile不一定是完整的
            self._x_tile_edge_diff = self._cnt_x_tile * TILE_WIDTH - sw
            self._y_tile_edge_diff = self._cnt_y_tile * TILE_HEIGHT - sh
            self.set_view_limit_rect(
                cc.Rect(
                    0, 0, min(sw, self._view_width), min(sh, self._view_height)
                )
            )
        else:
            self._w_scene, self._h_scene = self._view_width, self._view_height
            self.cnt_x_tile = int(ceil(self._view_width * 1.0 / TILE_WIDTH))
            self.cnt_y_tile = int(ceil(self._view_height * 1.0 / TILE_HEIGHT))
            self._grid_col = int(ceil(self._w_scene * 1.0 / CELLSIZE))
            self._grid_row = int(ceil(self._h_scene * 1.0 / CELLSIZE))

            # 最边缘的tile不一定是完整的
            self._x_tile_edge_diff = (
                self._cnt_x_tile * TILE_WIDTH - self._view_width
            )
            self._y_tile_edge_diff = (
                self._cnt_y_tile * TILE_HEIGHT - self._view_height
            )

        # 使用引擎对象加载遮罩、阻挡
        if not self.in_war_scene():
            # 加载遮罩
            mask_loader = None
            mask_ext_path = com_path.get_scene_mask_ext_path(self.res_id)

            # 暂时兼容新旧遮罩数据
            import C_file

            from common.avatar.core.utls import greater_than

            if (
                self._mask_loader_cache[0]
                and mask_ext_path == self._mask_loader_cache[1]
            ):  # 复用
                mask_loader = self._mask_loader_cache[0]
                self._mask_loader_cache = [None, None]
                logger.debug(
                    "Scene mask_loader reuse:", self.res_id, mask_ext_path
                )

            else:
                greater_flag = greater_than(
                    C_file.find_res_file(mask_ext_path, ""), 0
                )
                if greater_flag:
                    mask_loader = NewMaskLoader()
                    mask_loader.load(mask_ext_path)

            self.is_new_mask = global_data.enable_new_mask
            self.mask_loader = mask_loader
            self.mask_loader_path = mask_ext_path

        # 初始化一共要多少个地图背景图块，这些图块是重复使用的
        w, h = self._view_limit_rect.width, self._view_limit_rect.height

        if self.is_new_layer_running:
            if self.map_block_mgr:
                self.map_block_mgr.clear()
                self.map_block_mgr = None
            if self.multitiered_scene_mgr:
                self.multitiered_scene_mgr.clear_all_obj()
            self.init_multi_layer_obj()
        else:
            self.layer_mgr.clear_all_layer()
            # 初始化一共要多少个地图背景图块，这些图块是重复使用的
            self.reset_map_block(w / self.scene_scale, h / self.scene_scale)
            self.init_multi_layer_obj()

        # 背景层
        self.create_bg_layer()
        # 技优版先禁掉缩放场景
        # adjust_scale = self.get_scene_scale(scene_id, w, self._view_width)

        # # 针对notch的战斗底图进行拉伸，否则会留黑边
        # if global_data.is_notch_device and global_warinfo.is_war():
        # 	from gcommon.dutils.device_utils import get_notch_fight_scene_scale
        # 	adjust_scale = get_notch_fight_scene_scale()

        # self.set_scale(adjust_scale)
        # self.scene_scale = adjust_scale
        self.look_at_pos = (None, None)

        # 设置初始化视点
        l_x, l_y = self._view_org_x, self._view_org_y
        if look_center_pos:
            # 这个是中心坐标，要进行转换
            l_x, l_y = look_center_pos
            # l_x, l_y = l_x - self._view_limit_rect.width / 2, l_y - self._view_height / 2
            # l_x, l_y = max(0, l_x), max(0, l_y)
            # l_x, l_y = self.svr_pixel_convert_to_mobile_pixel(l_x, l_y)
            # print look_pos, l_x, l_y
            # 这边需要考虑在地图边缘的问题， 不然切场景的时候会闪动
            l_x, l_y = self._get_scroll_pos(l_x, l_y)
        self.look_at(l_x, l_y)

        if self.is_preload_map and self.is_load_scene_async:
            if self.is_new_layer_running:
                self.layer_mgr.preload_extra_map_textures()
            else:
                self.map_block_mgr.preload_extra_map_textures()
        self._is_ready = True
```

1. 从xy2reader模块中导入NewMaskLoader类。

2. 调用set_view_limit_rect方法，设置视域范围矩阵为一个cc.Rect对象，宽度为self._view_width，高度为self._view_height。

3. 调用get_scene_info方法，传入self.scene_id，获取场景信息，包括场景名称、场景宽度sw和场景高度sh。

4. 如果sw和sh都存在：

   将sw和sh赋值给self._w_scene和self._h_scene。
   计算场景中的瓦片数量self.cnt_x_tile和self.cnt_y_tile，分别为场景宽度和高度除以瓦片宽度TILE_WIDTH和瓦片高度TILE_HEIGHT的向上取整结果。
   计算场景中的网格列数self._grid_col和网格行数self._grid_row，分别为场景宽度和高度除以单元格大小CELLSIZE的向上取整结果。
   计算最边缘瓦片的差值self._x_tile_edge_diff和self._y_tile_edge_diff，分别为瓦片数量乘以瓦片宽度/高度减去场景宽度/高度的结果。
   调用set_view_limit_rect方法，设置视域范围矩阵为一个cc.Rect对象，宽度为场景宽度和视图宽度的较小值，高度为场景高度和视图高度的较小值。

5. 如果sw和sh不存在：

   将视图宽度和高度赋值给self._w_scene和self._h_scene。
   计算场景中的瓦片数量、网格列数和网格行数，与步骤4类似，但使用视图宽度和高度代替场景宽度和高度。
   计算最边缘瓦片的差值，与步骤4类似。

6. 如果不在战斗场景中（通过调用in_war_scene方法判断）：

   加载遮罩数据：
   调用com_path.get_scene_mask_ext_path方法获取场景遮罩的扩展路径mask_ext_path。
   如果self._mask_loader_cache中存在缓存的遮罩加载器且路径匹配，则复用缓存的加载器mask_loader，并清空缓存。
   否则，调用C_file.find_res_file方法查找遮罩文件，如果文件存在，则创建一个新的NewMaskLoader对象，并调用其load方法加载遮罩数据。
   设置self.is_new_mask为global_data.enable_new_mask的值，表示是否使用新的遮罩。
   将加载的遮罩加载器赋值给self.mask_loader，将遮罩路径赋值给self.mask_loader_path。

7. 获取视域范围矩形的宽度w和高度h。

8. 如果self.is_new_layer_running为True，表示使用新的图层运行：

   如果self.map_block_mgr存在，则调用其clear方法进行清理，并将其设置为None。
   如果self.multitiered_scene_mgr存在，则调用其clear_all_obj方法清理所有对象。
   调用init_multi_layer_obj方法初始化多层对象。

9. 如果self.is_new_layer_running为False：

   调用self.layer_mgr.clear_all_layer方法清理所有图层。
   调用reset_map_block方法，传入视域宽度和高度除以场景缩放比例self.scene_scale，重置地图块。
   调用init_multi_layer_obj方法初始化多层对象。

10. 调用create_bg_layer方法创建背景层。

11. 将(None, None)赋值给self.look_at_pos，表示初始化视点位置。

12. 获取视图原点坐标self._view_org_x和self._view_org_y，赋值给l_x和l_y。

13. 如果传入了look_center_pos参数：

    将look_center_pos赋值给l_x和l_y。
    调用_get_scroll_pos方法，传入l_x和l_y，获取滚动位置，并将结果赋值给l_x和l_y。

14. 调用look_at方法，传入l_x和l_y，设置视点位置。

15. 如果self.is_preload_map和self.is_load_scene_async都为True：

    如果self.is_new_layer_running为True，则调用self.layer_mgr.preload_extra_map_textures方法预加载额外的地图纹理。
    否则，调用self.map_block_mgr.preload_extra_map_textures方法预加载额外的地图纹理。

16. 将self._is_ready设置为True，表示地图初始化完成。

load_scene_background_music：背景音乐播放功能

attach_sprite_holder：

